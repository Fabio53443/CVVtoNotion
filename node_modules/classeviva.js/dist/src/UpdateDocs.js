"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = require("path");
const fs_1 = tslib_1.__importDefault(require("fs"));
const tab = '   ';
const data = {
    Methods: (cls) => Object.getOwnPropertyNames(Object.getPrototypeOf(new cls)).filter(method => method !== "constructor").map((m) => `> ${m}\n`),
    Properties: (cls) => Object.getOwnPropertyNames(new cls).map((prop) => `> ${prop}\n`),
};
(async () => {
    var _a;
    console.log('[üìÑ] Updating docs...');
    const dir = (0, path_1.join)(process.cwd(), `docs`);
    const classesPath = (0, path_1.join)(__dirname, 'classes');
    if (!await existsOrCreate({ path: dir }) || !await existsOrCreate({ path: classesPath }))
        return error('Missing paths');
    const classes = fs_1.default.readdirSync(classesPath).filter(file => file.endsWith('.js'));
    const files = Object.keys(data);
    let readmeString = '';
    for (const cls of classes) {
        console.log(`[üß±] Updating class "${cls}"...`);
        const clsPath = (0, path_1.join)(classesPath, cls);
        const { default: clsFile } = await (_a = clsPath, Promise.resolve().then(() => tslib_1.__importStar(require(_a))));
        const clsName = removeExtension(cls);
        const docClass = (0, path_1.join)(dir, clsName);
        await existsOrCreate({
            path: docClass,
            type: 'dir'
        });
        readmeString += `\n‚Ä¢ ${clsName}\n\n`;
        for (const file of files) {
            console.log(`${tab}- Updating file "${file}"...`);
            const filePath = (0, path_1.join)(docClass, `${file}.md`);
            await existsOrCreate({
                path: filePath,
                type: 'file'
            });
            const content = fs_1.default.readFileSync(filePath, 'utf8');
            const split = content.split(`# ${file}`);
            const toReplace = split.length > 0 ? (split.pop() ?? '') : '';
            const newContent = data[file](clsFile).join('\n');
            if (!toReplace.length) {
                console.log(`${tab}- "${file}" is empty ‚ö†Ô∏è`);
                fs_1.default.writeFileSync(filePath, `# ${file}\n\n${newContent}`);
            }
            else
                fs_1.default.writeFileSync(filePath, content.replace(toReplace, `\n\n${newContent}`));
            readmeString += `${tab}- [${file}](${clsName}/${file}.md)\n`;
            console.log(`${tab}- Updated "${file}" üÜó`);
        }
        console.log(`[‚úÖ] Updated class "${cls}"`);
    }
    await console.log('[üåê] Updated all classes');
    await readme(dir, readmeString);
    await examples(dir);
    return console.log('[üìÉ] Updated all files');
})();
async function readme(docsDir, newContent) {
    const path = (0, path_1.join)(docsDir, 'README.md');
    await existsOrCreate({
        path,
        type: 'file'
    });
    let content = await fs_1.default.readFileSync(path, 'utf-8');
    if (!content)
        content = '# Docs\nHere you can find infos about the classes contained in this package. Choose a document from the list below:\n\n## Documents';
    const split = content.split(`## Documents`);
    const toReplace = split.length > 0 ? (split.pop() ?? '') : '';
    if (!toReplace.length) {
        console.log(`${tab}- "README.md" is empty ‚ö†Ô∏è`);
        fs_1.default.writeFileSync(path, `${content}\n${newContent}`);
    }
    else {
        console.log(`${tab}- Updating "README.md"`);
        fs_1.default.writeFileSync(path, content.replace(toReplace, `\n${newContent}`));
    }
    console.log(`${tab}- Updated "README.md" ‚úÖ`);
}
async function examples(docsDir) {
    console.log('[üì¶] Updating examples...');
    const path = (0, path_1.join)(docsDir, 'Examples');
    await existsOrCreate({
        path,
        type: 'dir'
    });
    let string = "";
    const examples = fs_1.default.readdirSync(path);
    examples.forEach(async (example) => {
        string += `\n‚Ä¢ [${removeExtension(example)}](docs/Examples/${example})\n`;
        console.log(`${tab}- Added example "${example}" üÜó`);
    });
    if (!string.length) {
        string = '\nThere are no examples yet.\n';
        console.log(`${tab}- "Examples" folder is empty ‚ö†Ô∏è`);
    }
    const readmePath = (0, path_1.join)(process.cwd(), 'README.md');
    const readmeContent = await fs_1.default.readFileSync(readmePath, 'utf-8');
    const split = readmeContent.split(`## Examples`);
    if (split.length === 0)
        return error('Couldn\'t find "Examples" section in README.md');
    const toReplace = split.pop()?.split('##')[0] ?? '';
    fs_1.default.writeFileSync(readmePath, readmeContent.replace(toReplace, `\n${string}\n`));
    console.log('[‚úÖ] Updated examples');
    return;
}
async function existsOrCreate({ path, type = 'dir' }) {
    if (await fs_1.default.existsSync(path))
        return true;
    try {
        type === 'dir' ? await fs_1.default.mkdirSync(path, {
            recursive: true
        }) : await fs_1.default.writeFileSync(path, '');
        return true;
    }
    catch (e) {
        error(`Couldn't create "${path}" path\n`);
    }
}
function removeExtension(str) {
    return str.split('.')[0];
}
function error(msg) {
    console.log(`[‚ùå] ${msg}`);
    return process.exit(1);
}
//# sourceMappingURL=UpdateDocs.js.map